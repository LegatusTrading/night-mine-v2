#!/usr/bin/env python3
"""
Import HD wallets generated by generate-hd-wallet.sh into miner.py format
Uses Ed25519-BIP32 keys from .skey files with pycardano CIP-8 signing
Automatically registers wallets with the mining API
"""

import json
import os
import sys
import time
from datetime import datetime, timezone
import cbor2
import requests
from pycardano import PaymentExtendedSigningKey, StakeExtendedSigningKey, PaymentVerificationKey, Address, Network, sign
from proxy_config import create_proxy_session

def load_extended_signing_key(skey_path):
    """Load PaymentExtendedSigningKey from .skey file"""
    with open(skey_path, 'r') as f:
        skey_data = json.load(f)

    # Load as PaymentExtendedSigningKey (handles Ed25519-BIP32 properly)
    signing_key = PaymentExtendedSigningKey.from_json(json.dumps(skey_data))

    return signing_key

def load_stake_signing_key(skey_path):
    """Load StakeExtendedSigningKey from .skey file"""
    with open(skey_path, 'r') as f:
        skey_data = json.load(f)

    # Load as StakeExtendedSigningKey (handles Ed25519-BIP32 properly)
    signing_key = StakeExtendedSigningKey.from_json(json.dumps(skey_data))

    return signing_key

def derive_wallet_from_hd_files(hd_wallet_dir, account_num):
    """
    Load wallet from HD wallet files generated by generate-hd-wallet.sh
    Uses pycardano PaymentExtendedSigningKey for proper Ed25519-BIP32 handling
    Creates BASE addresses (payment + stake) for Eternl/sm.midnight.gd compatibility
    """

    # Read the payment .skey file
    payment_skey_path = os.path.join(hd_wallet_dir, f"account-{account_num}", "payment", "0", "payment.skey")
    if not os.path.exists(payment_skey_path):
        raise FileNotFoundError(f"Payment key file not found: {payment_skey_path}")

    # Read the stake .skey file
    stake_skey_path = os.path.join(hd_wallet_dir, f"account-{account_num}", "stake", "stake.skey")
    if not os.path.exists(stake_skey_path):
        raise FileNotFoundError(f"Stake key file not found: {stake_skey_path}")

    # Load extended signing keys (handles Ed25519-BIP32 properly)
    payment_extended_signing_key = load_extended_signing_key(payment_skey_path)
    stake_extended_signing_key = load_stake_signing_key(stake_skey_path)

    # Derive verification keys
    payment_verification_key = payment_extended_signing_key.to_verification_key()
    stake_verification_key = stake_extended_signing_key.to_verification_key()

    # Create BASE address (payment + stake) - matches Eternl and sm.midnight.gd
    address = Address(
        payment_part=payment_verification_key.hash(),
        staking_part=stake_verification_key.hash(),
        network=Network.MAINNET
    )

    # Extract just the 32-byte public key (not the extended key with chain code)
    vkey_bytes = bytes(payment_verification_key.to_primitive())
    pubkey = vkey_bytes[:32].hex()  # First 32 bytes only

    return {
        'address': str(address),
        'pubkey': pubkey,
        'extended_signing_key': payment_extended_signing_key,  # Store for CIP-8 signing
        'signature': None,  # Will be signed in sign_wallet_terms()
        'created_at': datetime.now(timezone.utc).isoformat()
    }

def sign_wallet_terms(wallet_data):
    """Sign the terms and conditions for a wallet using pycardano CIP-8"""
    try:
        # Use the standard T&C message
        message = "I agree to abide by the terms and conditions as described in version 1-0 of the Midnight scavenger mining process: 281ba5f69f4b943e3fb8a20390878a232787a04e4be22177f2472b63df01c200"

        # Get the extended signing key
        extended_signing_key = wallet_data['extended_signing_key']

        # Use pycardano's CIP-8 sign function (proper Ed25519-BIP32 signing)
        signature_hex = sign(message, extended_signing_key, network=Network.MAINNET)

        # Store the signature
        wallet_data['signature'] = signature_hex

        # Remove the extended_signing_key object before saving (can't serialize it)
        # We'll need to store it differently for the miner
        del wallet_data['extended_signing_key']

        return True
    except Exception as e:
        print(f"Error signing wallet: {e}")
        import traceback
        traceback.print_exc()
        return False

def register_wallet_with_api(wallet_data, api_base, session):
    """Register a wallet with the mining API (same as miner.py)"""
    url = f"{api_base}/register/{wallet_data['address']}/{wallet_data['signature']}/{wallet_data['pubkey']}"

    try:
        response = session.post(url, json={}, timeout=15)
        response.raise_for_status()
        return True, "Registered"
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 400:
            error_msg = e.response.json().get('message', '')
            if 'already' in error_msg.lower():
                return True, "Already registered"
        return False, f"HTTP {e.response.status_code}: {e.response.text}"
    except Exception as e:
        return False, str(e)

def main():
    if len(sys.argv) < 2:
        print("Usage: ./import-hd-wallets.py <hd-wallet-dir> [num_accounts]")
        print("")
        print("Example:")
        print("  ./import-hd-wallets.py ./hd-wallets 16")
        print("")
        print("This reads the wallet files generated by generate-hd-wallet.sh")
        print("and creates wallets.json for miner.py")
        sys.exit(1)

    hd_wallet_dir = sys.argv[1]
    num_accounts = int(sys.argv[2]) if len(sys.argv) > 2 else 16

    if not os.path.exists(hd_wallet_dir):
        print(f"Error: Directory {hd_wallet_dir} not found")
        print("Run generate-hd-wallet.sh first!")
        sys.exit(1)

    # Read the mnemonic
    mnemonic_file = os.path.join(hd_wallet_dir, "mnemonic.txt")
    if not os.path.exists(mnemonic_file):
        print(f"Error: Mnemonic file not found: {mnemonic_file}")
        sys.exit(1)

    with open(mnemonic_file, 'r') as f:
        mnemonic = f.read().strip()

    print(f"Importing {num_accounts} HD wallet accounts using Ed25519-BIP32 keys")
    print(f"Mnemonic words: {len(mnemonic.split())}")
    print(f"Using .skey files from: {hd_wallet_dir}")
    print()

    # Create HTTP session for API registration
    api_base = "https://scavenger.prod.gd.midnighttge.io/"
    session, _ = create_proxy_session()

    wallets = []
    for account_num in range(num_accounts):
        try:
            wallet = derive_wallet_from_hd_files(hd_wallet_dir, account_num)
            short_addr = wallet['address'][:20] + "..."
            print(f"Account {account_num}: {short_addr}", end='')

            # Sign the terms and conditions
            if not sign_wallet_terms(wallet):
                print(" ✗ Failed to sign")
                sys.exit(1)

            # Register with API
            success, message = register_wallet_with_api(wallet, api_base, session)
            if success:
                print(f" ✓ Signed & {message}")
                wallets.append(wallet)
            else:
                print(f" ✗ Registration failed: {message}")
                print("\n⚠️  Wallet signature verification failed!")
                print("This usually means:")
                print("  1. API is unreachable")
                print("  2. Network connectivity issue")
                print("\nYou can manually register later with:")
                print("  .venv/bin/python3 register-wallets.py")
                sys.exit(1)

            # Small delay between registrations
            if account_num < num_accounts - 1:
                time.sleep(0.3)

        except Exception as e:
            print(f"\n✗ Account {account_num}: Error - {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)

    # Backup existing wallets.json
    if os.path.exists("wallets.json"):
        backup = f"wallets.json.backup-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        os.rename("wallets.json", backup)
        print(f"\n✓ Backed up old wallets.json to {backup}")

    # Write new wallets.json
    with open("wallets.json", 'w') as f:
        json.dump(wallets, f, indent=2)

    print(f"\n✓ Created wallets.json with {len(wallets)} wallets")
    print(f"✓ All wallets signed with terms & conditions")
    print("\nNext steps:")
    print("  make start-local     # Start mining")
    print("  make watch-local     # Monitor mining")
    print(f"\n⚠️  IMPORTANT: Backup {hd_wallet_dir}/mnemonic.txt - it controls all wallets!")

if __name__ == "__main__":
    main()
